// __multiversion__

#include "fragmentVersionCentroid.h"

#include "uniformShaderConstants.h"
#include "uniformPerFrameConstants.h"
#include "util.h"

#include "uniformInterFrameConstants.h"

#include "includes/color_correction.glsl"
#include "includes/random.glsl"
#include "includes/env_detectors.glsl"

//settings
#include "includes/options/quality_settings/clouds/clouds_enabled.glsl"
#include "includes/options/quality_settings/clouds/clouds_details.glsl"
#include "includes/options/quality_settings/clouds/advanced_clouds_shadow.glsl"

varying vec4 position;

void main()
{
	float is_rain = detectRain();
	is_rain = clamp(is_rain, 0.0, 1.0);// todo: have no idea why but clamp() doesnt work in detectRain() for this shader file


	vec3 sphereNormal = normalize(-position.xyz);

	float horizonOffset = -0.125;
	float horizonScale = 4.0;

	float horizon =  1.0 - abs(position.y + horizonOffset) / length(position.xyz);
	horizon = pow(horizon, 16.0 / horizonScale);
	horizon = clamp(horizon, 0.0, 1.0);
	float zenith = 1.0 - horizon;

	vec3 horizonColor = pow(FOG_COLOR.rgb, vec3(0.6));
	
	vec3 zenithColor = vec3(0.125, 0.25, 0.5) * length(horizonColor);
	// zenithColor = mix(zenithColor, horizonColor, is_rain);

	vec3 skyColor = mix(zenithColor, horizonColor, horizon);
	
	
	#ifdef CLOUDS_ENABLED
		vec3 skyColorGrayscale = vec3((skyColor.r + skyColor.g + skyColor.b) / 3.0);
		
		highp vec2 cldCoord = vec2(-sphereNormal.x, sphereNormal.z);
		cldCoord /= (abs(position.y + horizonOffset) / length(position.xyz));
		
		float clouds = cloudsPerlin(CLOUDS_DETAILS, cldCoord / 16.0);

		#ifdef ADVANCED_CLOUDS_SHADOW
			float cloudsShadow = cloudsPerlin(0, cldCoord * 0.85 / 16.0) * clouds;
		#else
			float cloudsShadow = clouds * 0.7;
		#endif

		clouds = pow(clamp(clouds * 1.75, 0.0, 1.0), mix(16.0, 0.25, is_rain));
		clouds = clamp(clouds, 0.0, 1.0);
		cloudsShadow = pow(clamp(cloudsShadow * 2.0, 0.0, 1.0), 1.0);


		vec3 cloudsColor = vec3(1.75) * pow(length(skyColor.gb), 2.0);


		float shadowDesaturation = 0.25;
		float additionalRainShadowDesaturation = 0.5;
		float resultShadowDesaturation = shadowDesaturation + additionalRainShadowDesaturation * is_rain;

		float shadowDarkening = 0.1;
		float additionalRainShadowDarkening = 0.1;
		float resultDarkening = 1.0 - shadowDarkening - (additionalRainShadowDarkening * is_rain);
		
		vec3 cloudsShadowColor = mix(skyColor.rgb, skyColorGrayscale, resultShadowDesaturation) * resultDarkening;

		cloudsColor = mix(cloudsColor, cloudsShadowColor, cloudsShadow);

		skyColor.rgb = mix(skyColor.rgb, cloudsColor, clouds * zenith);
	#endif



	//final stage
	skyColor.rgb = colorCorrection(skyColor.rgb);

	gl_FragColor.rgb = skyColor.rgb;
	gl_FragColor.a = 1.0;
}
